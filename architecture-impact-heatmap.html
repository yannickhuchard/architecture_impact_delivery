<!DOCTYPE html>
<html>
<head>
    <title>Program Dependency Heatmap</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
    <style>
        .controls { margin: 20px; padding: 10px; background: #f5f5f5; }
        .filter-group { margin: 10px 0; }
        
        /* Tab Styles */
        .tab-container {
            width: 100%;
            margin: 20px 0;
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 10px 20px;
            border: none;
            background: #f0f0f0;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        .tab-button.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
            width: 100%;
            height: 90vh;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="filter-group">
            <label>Project Files:</label>
            <input type="file" id="xlsxInput" multiple accept=".xlsx">
        </div>
        <div class="filter-group">
            <label>Team Mapping File:</label>
            <input type="file" id="teamMappingInput" accept=".xlsx">
        </div>
        <div class="filter-group">
            <select id="periodType">
                <option value="all">All Periods</option>
                <option value="quarter">By Quarter</option>
                <option value="month">By Month</option>
            </select>
            <select id="periodSelect" disabled>
                <option value="all">All</option>
            </select>
        </div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="heatmap">Capability Heatmap</button>
            <button class="tab-button" data-tab="sankey">Dependency Flow</button>
            <button class="tab-button" data-tab="hierarchy">Program Hierarchy</button>
            <button class="tab-button" data-tab="budget">Estimated Budgets Overview</button>
            <button class="tab-button" data-tab="dependencies">Program Dependencies</button>
        </div>
        <div id="heatmapTab" class="tab-content active">
            <div id="chartContainer" style="width: 100%; height: 100%;"></div>
        </div>
        <div id="sankeyTab" class="tab-content">
            <div id="sankeyContainer" style="width: 100%; height: 100%;"></div>
        </div>
        <div id="hierarchyTab" class="tab-content">
            <div id="circlePackingContainer" style="width: 100%; height: 100%;"></div>
        </div>
        <div id="budgetTab" class="tab-content">
            <div id="budgetContainer" style="width: 100%; height: 100%; display: flex; flex-wrap: wrap;"></div>
        </div>
        <div id="dependenciesTab" class="tab-content">
            <div id="dependenciesContainer" style="width: 100%; height: 100%;"></div>
        </div>
    </div>

    <script>
        let allData = [];
        let teamMappings = [];
        let myChart = null;
        let sankeyChart = null;
        let circlePackingChart = null;
        let dependenciesChart = null;

        document.getElementById('xlsxInput').addEventListener('change', handleFile);
        document.getElementById('teamMappingInput').addEventListener('change', handleTeamMapping);
        document.getElementById('periodType').addEventListener('change', updatePeriodSelect);
        document.getElementById('periodSelect').addEventListener('change', updateVisualizations);

        // Update the tab switching functionality
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Update button states
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                document.getElementById(`${button.dataset.tab}Tab`).classList.add('active');
                
                // Trigger resize for the visible chart with a slight delay
                setTimeout(() => {
                    if (button.dataset.tab === 'heatmap' && myChart) {
                        myChart.resize();
                    } else if (button.dataset.tab === 'sankey' && sankeyChart) {
                        sankeyChart.resize();
                    } else if (button.dataset.tab === 'hierarchy' && circlePackingChart) {
                        circlePackingChart.resize();
                    } else if (button.dataset.tab === 'budget') {
                        // Resize all budget charts
                        const budgetCharts = document.querySelectorAll('#budgetContainer > div');
                        budgetCharts.forEach(div => {
                            const chart = echarts.getInstanceByDom(div);
                            if (chart) {
                                chart.resize();
                            }
                        });
                    } else if (button.dataset.tab === 'dependencies' && dependenciesChart) {
                        dependenciesChart.resize();
                    }
                }, 50);
            });
        });

        function handleFile(e) {
            allData = [];
            const files = Array.from(e.target.files);
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    workbook.SheetNames.forEach(sheetName => {
                        const sheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(sheet);
                        allData = allData.concat(jsonData);
                    });
                    updatePeriodSelect();
                    updateVisualizations();
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function handleTeamMapping(e) {
            teamMappings = [];
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    teamMappings = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
                    updateVisualizations();
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function updateVisualizations() {
            if (allData.length > 0) {
                updateChart();
                updateCirclePacking();
                updateBudgetCharts();
                updateProgramDependencies();
                document.querySelector('[data-tab="budget"]').style.display = 'block';
                document.querySelector('[data-tab="dependencies"]').style.display = 'block';
            } else {
                document.querySelector('[data-tab="budget"]').style.display = 'none';
                document.querySelector('[data-tab="dependencies"]').style.display = 'none';
            }
            
            if (allData.length > 0 && teamMappings.length > 0) {
                updateSankeyDiagram();
                document.querySelector('[data-tab="sankey"]').style.display = 'block';
            } else {
                document.querySelector('[data-tab="sankey"]').style.display = 'none';
            }
        }

        function updatePeriodSelect() {
            const periodType = document.getElementById('periodType').value;
            const select = document.getElementById('periodSelect');
            select.disabled = periodType === 'all';
            
            const periods = Array.from(new Set(allData.map(d => {
                const period = d['Delivery Period'];
                if(periodType === 'quarter') return period.split('-')[0] ? period : `${new Date(period).getFullYear()}-Q${Math.ceil((new Date(period).getMonth()+1)/3)}`;
                if(periodType === 'month') return period.includes('/') ? period : `${String(new Date(period).getMonth()+1).padStart(2,'0')}/${new Date(period).getFullYear()}`;
                return 'all';
            }))).sort();

            select.innerHTML = periodType === 'all' 
                ? '<option value="all">All</option>' 
                : '<option value="all">All</option>' + periods.map(p => `<option value="${p}">${p}</option>`).join('');
        }

        function updateChart() {
            const filteredData = filterData();
            const processed = processData(filteredData);
            if(!myChart) myChart = echarts.init(document.getElementById('chartContainer'));
            
            const option = {
                tooltip: {
                    formatter: params => `
                        <strong>${processed.programs[params.data[0]]}</strong><br>
                        ${processed.capabilities[params.data[1]]}<br>
                        Dependencies: ${params.data[2]}<br>
                        Projects: ${processed.detailsMap.get(`${params.data[0]}-${params.data[1]}`).join(', ')}
                    `
                },
                xAxis: { 
                    type: 'category', 
                    data: processed.programs,
                    axisLabel: { 
                        rotate: 45,
                        formatter: value => value.length > 20 ? value.substring(0, 20) + '...' : value
                    }
                },
                yAxis: { type: 'category', data: processed.capabilities },
                visualMap: {
                    min: 0,
                    max: Math.max(...processed.matrix.map(m => m[2])),
                    calculable: true,
                    inRange: { color: ['#ffffff', '#98fb98', '#f0e68c', '#ffb6c1', '#cd5c5c'] }
                },
                series: [{
                    type: 'heatmap',
                    data: processed.matrix.map(m => [m[0], m[1], m[2]]),
                    label: { 
                        show: true, 
                        formatter: params => params.data[2] > 0 ? params.data[2] : '' 
                    }
                }]
            };
            
            myChart.setOption(option);
            window.addEventListener('resize', () => myChart.resize());
        }

        function filterData() {
            const periodType = document.getElementById('periodType').value;
            const period = document.getElementById('periodSelect').value;
            return allData.filter(d => {
                if(periodType === 'all') return true;
                const dp = d['Delivery Period'];
                const currentPeriod = periodType === 'quarter' 
                    ? dp.includes('Q') ? dp : `${new Date(dp).getFullYear()}-Q${Math.ceil((new Date(dp).getMonth()+1)/3)}`
                    : dp.includes('/') ? dp : `${String(new Date(dp).getMonth()+1).padStart(2,'0')}/${new Date(dp).getFullYear()}`;
                return currentPeriod === period;
            });
        }

        function processData(data) {
            const programs = [...new Set(data.map(d => d['Program Name']))];
            const capabilities = [...new Set(data.map(d => `${d['Capability Domain']}: ${d['Capability Name']}`))];
            const matrix = [];
            const detailsMap = new Map();

            programs.forEach((program, pIdx) => {
                capabilities.forEach((capability, cIdx) => {
                    const entries = data.filter(d => 
                        d['Program Name'] === program && 
                        `${d['Capability Domain']}: ${d['Capability Name']}` === capability
                    );
                    if(entries.length) {
                        matrix.push([pIdx, cIdx, entries.length, entries.map(e => e['Project Name'])]);
                        detailsMap.set(`${pIdx}-${cIdx}`, entries.map(e => e['Project Name']));
                    }
                });
            });

            return { programs, capabilities, matrix, detailsMap };
        }

        function updateSankeyDiagram() {
            const filteredData = filterData();
            if (!sankeyChart) sankeyChart = echarts.init(document.getElementById('sankeyContainer'));

            // Prepare nodes and links for Sankey diagram
            const nodes = [];
            const links = [];
            const nodeMap = new Map();

            // Helper function to add node and get its index
            function addNode(name, category) {
                const key = `${category}:${name}`;
                if (!nodeMap.has(key)) {
                    nodeMap.set(key, nodes.length);
                    nodes.push({ name: name, category: category });
                }
                return nodeMap.get(key);
            }

            // Add program nodes and project links
            filteredData.forEach(project => {
                const programIdx = addNode(project['Program Name'], 'program');
                const projectIdx = addNode(project['Project Name'], 'project');
                const capabilityIdx = addNode(
                    `${project['Capability Domain']}: ${project['Capability Name']}`,
                    'capability'
                );

                // Program to Project link
                links.push({
                    source: programIdx,
                    target: projectIdx,
                    value: 1
                });

                // Project to Capability link
                links.push({
                    source: projectIdx,
                    target: capabilityIdx,
                    value: 1
                });

                // Find team for this capability and add link
                const teamMapping = teamMappings.find(tm => 
                    tm['Capability Domain'] === project['Capability Domain'] &&
                    tm['Capability Name'] === project['Capability Name']
                );

                if (teamMapping) {
                    const teamIdx = addNode(teamMapping['Team Name'], 'team');
                    links.push({
                        source: capabilityIdx,
                        target: teamIdx,
                        value: 1
                    });
                }
            });

            const option = {
                title: {
                    text: 'Program to Team Dependencies',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'item',
                    triggerOn: 'mousemove'
                },
                series: [{
                    type: 'sankey',
                    data: nodes,
                    links: links,
                    emphasis: {
                        focus: 'adjacency'
                    },
                    levels: [
                        { depth: 0, itemStyle: { color: '#e31a1c' } },  // Programs
                        { depth: 1, itemStyle: { color: '#33a02c' } },  // Projects
                        { depth: 2, itemStyle: { color: '#1f78b4' } },  // Capabilities
                        { depth: 3, itemStyle: { color: '#6a3d9a' } }   // Teams
                    ],
                    lineStyle: {
                        color: 'gradient',
                        curveness: 0.5
                    },
                    label: {
                        position: 'right'
                    }
                }]
            };

            sankeyChart.setOption(option);
            window.addEventListener('resize', () => sankeyChart.resize());
        }

        function updateCirclePacking() {
            const filteredData = filterData();
            if (!circlePackingChart) {
                circlePackingChart = echarts.init(document.getElementById('circlePackingContainer'));
            }

            // Prepare hierarchical data
            const hierarchyData = {
                name: 'root',
                children: []
            };

            // Group by programs
            const programGroups = new Map();
            filteredData.forEach(item => {
                if (!programGroups.has(item['Program Name'])) {
                    programGroups.set(item['Program Name'], new Map());
                }
                const projectMap = programGroups.get(item['Program Name']);
                
                if (!projectMap.has(item['Project Name'])) {
                    projectMap.set(item['Project Name'], new Set());
                }
                projectMap.get(item['Project Name']).add(
                    `${item['Capability Domain']}: ${item['Capability Name']}`
                );
            });

            // Build hierarchy
            programGroups.forEach((projectMap, programName) => {
                const programNode = {
                    name: programName,
                    value: 1,
                    children: []
                };

                projectMap.forEach((capabilities, projectName) => {
                    const projectNode = {
                        name: projectName,
                        value: 1,
                        children: Array.from(capabilities).map(cap => ({
                            name: cap,
                            value: 1
                        }))
                    };
                    programNode.children.push(projectNode);
                });

                hierarchyData.children.push(programNode);
            });

            const option = {
                title: {
                    text: 'Program Hierarchy',
                    left: 'center'
                },
                tooltip: {
                    formatter: (params) => {
                        const data = params.data;
                        const value = data.value;
                        if (data.children) {
                            const childCount = data.children.length;
                            return `${data.name}<br/>Contains: ${childCount} ${
                                data.children[0].children ? 'Projects' : 'Capabilities'
                            }`;
                        }
                        return data.name;
                    }
                },
                series: {
                    type: 'treemap',
                    layoutAlgorithm: 'squarified',
                    nodeClick: false,
                    roam: false,
                    width: '100%',
                    height: '100%',
                    data: [hierarchyData],
                    levels: [
                        {
                            itemStyle: {
                                borderColor: '#555',
                                borderWidth: 4,
                                gapWidth: 4
                            }
                        },
                        {
                            itemStyle: {
                                borderColor: '#333',
                                borderWidth: 3,
                                gapWidth: 3
                            }
                        },
                        {
                            itemStyle: {
                                borderColor: '#222',
                                borderWidth: 2,
                                gapWidth: 2
                            }
                        }
                    ],
                    label: {
                        show: true
                    },
                    upperLabel: {
                        show: true,
                        height: 30
                    }
                }
            };

            circlePackingChart.setOption(option);
            window.addEventListener('resize', () => circlePackingChart.resize());
        }

        function updateBudgetCharts() {
            const budgetContainer = document.getElementById('budgetContainer');
            // Clear existing charts properly
            const existingCharts = document.querySelectorAll('#budgetContainer > div');
            existingCharts.forEach(div => {
                const chart = echarts.getInstanceByDom(div);
                if (chart) {
                    chart.dispose();
                }
            });
            budgetContainer.innerHTML = '';
            budgetContainer.style.display = 'flex';
            budgetContainer.style.flexDirection = 'column';
            budgetContainer.style.alignItems = 'center';
            budgetContainer.style.overflowY = 'auto';

            // Group data by program
            const programData = new Map();
            allData.forEach(item => {
                if (!programData.has(item['Program Name'])) {
                    programData.set(item['Program Name'], new Map());
                }
                const projectMap = programData.get(item['Program Name']);
                
                if (!projectMap.has(item['Project Name'])) {
                    // Fix budget parsing: remove € symbol, replace dots, then parse
                    const budget = item['Total Cost Estimation'] ? 
                        parseInt(item['Total Cost Estimation']
                            .replace('€', '')
                            .replace(/\./g, '')
                            .replace(',', '.')) : 0;
                            
                    projectMap.set(item['Project Name'], {
                        count: 0,
                        budget: budget
                    });
                }
                projectMap.get(item['Project Name']).count++;
            });

            // Create a chart for each program
            programData.forEach((projectMap, programName) => {
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '90%';
                chartDiv.style.height = '600px';
                chartDiv.style.marginBottom = '30px';
                budgetContainer.appendChild(chartDiv);

                const chart = echarts.init(chartDiv);

                const projects = Array.from(projectMap.entries());
                const projectNames = projects.map(([name]) => name);
                const projectCounts = projects.map(([_, data]) => data.count);
                const projectBudgets = projects.map(([_, data]) => data.budget);
                
                // Calculate total budget for percentage
                const totalBudget = projectBudgets.reduce((a, b) => a + b, 0);

                const option = {
                    title: {
                        text: programName,
                        left: 'center',
                        top: 20,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: (params) => {
                            if (params.seriesIndex === 0) {
                                return `${params.name}<br/>Capabilities: ${params.value}`;
                            } else {
                                const percentage = ((params.value / totalBudget) * 100).toFixed(1);
                                return `${params.name}<br/>Budget: €${params.value.toLocaleString('de-DE')} (${percentage}%)`;
                            }
                        }
                    },
                    legend: {
                        type: 'scroll',
                        orient: 'vertical',
                        right: '5%',
                        top: 'middle',
                        data: projectNames
                    },
                    series: [
                        {
                            name: 'Capabilities',
                            type: 'pie',
                            selectedMode: 'single',
                            radius: [0, '30%'],
                            center: ['40%', '50%'],
                            label: {
                                position: 'inner',
                                fontSize: 14,
                                formatter: '{b}\n{c}'
                            },
                            labelLine: {
                                show: false
                            },
                            data: projectNames.map((name, i) => ({
                                name: name,
                                value: projectCounts[i]
                            }))
                        },
                        {
                            name: 'Budget',
                            type: 'pie',
                            radius: ['45%', '60%'],
                            center: ['40%', '50%'],
                            labelLine: {
                                length: 30
                            },
                            label: {
                                formatter: (params) => {
                                    const percentage = ((params.value / totalBudget) * 100).toFixed(1);
                                    return `${params.name}\n€${params.value.toLocaleString('de-DE')}\n${percentage}%`;
                                },
                                backgroundColor: '#F6F8FC',
                                borderColor: '#8C8D8E',
                                borderWidth: 1,
                                borderRadius: 4,
                                padding: [4, 8],
                                rich: {
                                    b: {
                                        color: '#4C5058',
                                        fontSize: 14,
                                        fontWeight: 'bold',
                                        lineHeight: 22
                                    },
                                    per: {
                                        color: '#fff',
                                        backgroundColor: '#4C5058',
                                        padding: [2, 4],
                                        borderRadius: 4
                                    }
                                }
                            },
                            data: projectNames.map((name, i) => ({
                                name: name,
                                value: projectBudgets[i]
                            }))
                        }
                    ]
                };

                chart.setOption(option);
                
                // Ensure chart resizes properly when container becomes visible
                const resizeObserver = new ResizeObserver(() => {
                    chart.resize();
                });
                resizeObserver.observe(chartDiv);
            });
        }

        function updateProgramDependencies() {
            if (!dependenciesChart) {
                dependenciesChart = echarts.init(document.getElementById('dependenciesContainer'));
            }

            // Get all programs and assign colors
            const programs = [...new Set(allData.map(d => d['Program Name']))];
            const colors = [
                '#ff7f50', '#87cefa', '#da70d6', '#32cd32', '#6495ed',
                '#ff69b4', '#ba55d3', '#cd5c5c', '#ffa500', '#40e0d0'
            ];
            const programColors = Object.fromEntries(
                programs.map((prog, i) => [prog, colors[i % colors.length]])
            );

            // Create capability map for each program
            const programCapabilities = new Map();
            allData.forEach(item => {
                if (!programCapabilities.has(item['Program Name'])) {
                    programCapabilities.set(item['Program Name'], new Set());
                }
                programCapabilities.get(item['Program Name']).add(
                    `${item['Capability Domain']}:${item['Capability Name']}`
                );
            });

            // Calculate shared capabilities between programs
            const links = [];
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    const prog1 = programs[i];
                    const prog2 = programs[j];
                    const caps1 = programCapabilities.get(prog1);
                    const caps2 = programCapabilities.get(prog2);
                    const shared = new Set([...caps1].filter(x => caps2.has(x)));
                    
                    if (shared.size > 0) {
                        links.push({
                            source: prog1,
                            target: prog2,
                            value: shared.size,
                            capabilities: Array.from(shared)
                        });
                    }
                }
            }

            const option = {
                title: {
                    text: 'Program Dependencies (Shared Capabilities)',
                    left: 'center',
                    top: 20
                },
                tooltip: {
                    trigger: 'item',
                    formatter: (params) => {
                        if (params.dataType === 'edge') {
                            return `${params.data.source} ↔ ${params.data.target}<br/>` +
                                   `Shared Capabilities: ${params.data.value}<br/>` +
                                   params.data.capabilities.map(cap => 
                                       `• ${cap.replace(':', ': ')}`
                                   ).join('<br/>');
                        }
                        return params.name;
                    }
                },
                legend: {
                    data: programs,
                    orient: 'vertical',
                    right: 20,
                    top: 'middle',
                    formatter: (name) => {
                        const count = programCapabilities.get(name).size;
                        return `${name} (${count} capabilities)`;
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'circular',
                    symbolSize: 40,
                    circular: {
                        rotateLabel: true
                    },
                    label: {
                        show: true,
                        position: 'right',
                        formatter: (params) => params.data.name.split(' ')[0]
                    },
                    edgeLabel: {
                        show: true,
                        formatter: '{c}'
                    },
                    data: programs.map(prog => ({
                        name: prog,
                        itemStyle: {
                            color: programColors[prog]
                        }
                    })),
                    links: links,
                    lineStyle: {
                        width: 2,
                        curveness: 0.3,
                        opacity: 0.7
                    },
                    emphasis: {
                        focus: 'adjacency',
                        lineStyle: {
                            width: 4
                        }
                    }
                }]
            };

            dependenciesChart.setOption(option);
            window.addEventListener('resize', () => dependenciesChart.resize());
        }
    </script>
</body>
</html>