<!DOCTYPE html>
<html>
<head>
    <title>Program Dependency Heatmap</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
    <style>
        .controls {
            margin: 20px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            position: relative;
        }

        .filter-group label {
            min-width: 150px;
            font-weight: bold;
            color: #444;
        }

        .filter-group input[type="file"],
        .filter-group select {
            flex: 1;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }

        .period-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .period-selects {
            display: flex;
            gap: 10px;
            flex: 1;
        }

        .period-selects select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            flex: 1;
        }
        
        /* Tab Styles */
        .tab-container {
            width: 100%;
            margin: 20px 0;
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 10px 20px;
            border: none;
            background: #f0f0f0;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        .tab-button.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
            width: 100%;
            height: 90vh;
            overflow: auto;
        }
        .tab-content.active {
            display: block;
        }

        .menu-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: #007bff;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .menu {
            position: fixed;
            top: 60px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 1000;
        }

        .menu.active {
            display: block;
        }

        .menu-item {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            z-index: 1001;
        }

        .dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1002;
        }

        .dialog h2 {
            margin-top: 0;
            color: #007bff;
        }

        .dialog-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        }

        .file-format {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .metrics-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .metric-title {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .top-projects {
            grid-column: 1 / -1;
        }

        .top-projects-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
            padding: 0 20px;
        }

        .project-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: transform 0.2s;
        }

        .project-item:hover {
            transform: translateX(5px);
            background: #f0f0f0;
        }

        .project-rank {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }

        .project-rank.gold {
            color: #FFD700;
        }

        .project-rank.silver {
            color: #C0C0C0;
        }

        .project-rank.bronze {
            color: #CD7F32;
        }

        .medal {
            font-size: 20px;
        }

        .project-capabilities {
            font-weight: bold;
            color: #007bff;
        }

        .rankings-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            padding: 20px;
            height: 100%;
            overflow-y: auto;
        }

        .ranking-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .ranking-section h3 {
            color: #007bff;
            margin-bottom: 20px;
            text-align: center;
        }

        body {
            font-family: Verdana, Geneva, sans-serif;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        .zoom-button {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }

        .zoom-button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }

        .zoom-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .app-title {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 20px;
        }

        .app-title h1 {
            margin: 0;
            color: #007bff;
            font-size: 24px;
            font-weight: bold;
        }

        .coach-mark {
            position: absolute;
            background: #007bff;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: pulse 2s infinite;
            display: none;
            right: -280px;
            top: 50%;
            transform: translateY(-50%);
        }

        .coach-mark::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -10px;
            transform: translateY(-50%);
            border-width: 10px 10px 10px 0;
            border-style: solid;
            border-color: transparent #007bff transparent transparent;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .view-toggle {
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: #007bff;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        .toggle-label {
            font-size: 14px;
            color: #666;
        }

        #heatmapTab {
            display: flex;
            flex-direction: column;
        }

        #chartContainer {
            width: 100%;
            min-height: 800px;
            height: calc(90vh - 40px);
            margin-bottom: 40px;
        }

        .resource-charts-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: calc(100vh - 200px);  /* Ensure container has height */
            width: 100%;
            position: relative;
        }

        #resourceAllocationChart, #resourceHeatmapChart {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 600px;  /* Ensure minimum height */
            flex: 1;  /* Take remaining space */
            width: 100% !important;  /* Force width */
            height: 600px !important;  /* Force height */
            position: relative;
        }
    </style>
</head>
<body>
    <div class="app-title">
        <h1>Enterprise Architecture - Capabilities Delivery Flow</h1>
    </div>
    <div class="controls">
        <div class="filter-group">
            <label>Project Files:</label>
            <input type="file" id="xlsxInput" multiple accept=".xlsx">
            <div id="programCoach" class="coach-mark">
                1: Load all your program files
            </div>
        </div>
        <div class="filter-group">
            <label>Team Mapping File:</label>
            <input type="file" id="teamMappingInput" accept=".xlsx">
            <div id="teamCoach" class="coach-mark">
                2: Load the Team-Capabilities mapping file
            </div>
        </div>
        <div class="filter-group">
            <label>Resource Files:</label>
            <input type="file" id="resourcesInput" multiple accept=".xlsx">
            <div id="resourceCoach" class="coach-mark">
                3: Load the project resource allocation files
            </div>
        </div>
        <div class="filter-group period-controls">
            <label>Period:</label>
            <div class="period-selects">
            <select id="periodType">
                <option value="all">All Periods</option>
                <option value="quarter">By Quarter</option>
                <option value="month">By Month</option>
            </select>
            <select id="periodSelect" disabled>
                <option value="all">All</option>
            </select>
        </div>
    </div>
    </div>

    <div class="metrics-dashboard">
        <div class="metric-card">
            <div class="metric-title">Programs</div>
            <div class="metric-value" id="programCount">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Projects</div>
            <div class="metric-value" id="projectCount">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Capabilities</div>
            <div class="metric-value" id="capabilityCount">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Teams</div>
            <div class="metric-value" id="teamCount">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Avg Projects/Program</div>
            <div class="metric-value" id="avgProjectsPerProgram">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Avg Capabilities/Program</div>
            <div class="metric-value" id="avgCapabilitiesPerProgram">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Avg Teams/Program</div>
            <div class="metric-value" id="avgTeamsPerProgram">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Total Resources</div>
            <div class="metric-value" id="totalResources">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Avg Resources/Project</div>
            <div class="metric-value" id="avgResourcesPerProject">-</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Total Estimated Man/Days</div>
            <div class="metric-value" id="totalManDays">-</div>
        </div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="heatmap">Capability Heatmap</button>
            <button class="tab-button" data-tab="sankey">Dependency Flow</button>
            <button class="tab-button" data-tab="hierarchy">Program Hierarchy</button>
            <button class="tab-button" data-tab="budget">Estimated Budgets Overview</button>
            <button class="tab-button" data-tab="dependencies">Program Dependencies</button>
            <button class="tab-button" data-tab="network">Program-Capability Network</button>
            <button class="tab-button" data-tab="rankings">Top 10 Rankings</button>
            <button class="tab-button" data-tab="gantt">Delivery Timeline</button>
            <button class="tab-button" data-tab="resourcesTab">Resource Allocation</button>
        </div>
        <div id="heatmapTab" class="tab-content active">
            <div class="view-toggle">
                <label class="switch">
                    <input type="checkbox" id="viewToggle">
                    <span class="slider round"></span>
                </label>
                <span class="toggle-label">Show Projects View</span>
            </div>
            <div id="chartContainer" style="width: 100%; height: calc(100% - 40px);"></div>
        </div>
        <div id="sankeyTab" class="tab-content">
            <div class="zoom-controls" style="top: 80px;">
                <button class="zoom-button" onclick="zoomSankey(1.2)">🔍+</button>
                <button class="zoom-button" onclick="zoomSankey(0.8)">🔍-</button>
            </div>
            <div id="sankeyContainer" style="width: 100%; height: calc(100vh - 200px); margin-top: 20px;"></div>
        </div>
        <div id="hierarchyTab" class="tab-content">
            <div id="circlePackingContainer" style="width: 100%; height: 100%;"></div>
        </div>
        <div id="budgetTab" class="tab-content">
            <div id="budgetContainer" style="width: 100%; height: 100%; display: flex; flex-wrap: wrap;"></div>
        </div>
        <div id="dependenciesTab" class="tab-content">
            <div id="dependenciesContainer" style="width: 100%; height: 100%;"></div>
        </div>
        <div id="networkTab" class="tab-content">
            <div style="padding: 10px; background: #f5f5f5; margin: 10px;">
                <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 10px;">
                    <div>
                        <label for="programSelect">Program: </label>
                        <select id="programSelect">
                            <option value="">All Programs</option>
                        </select>
                    </div>
                    <div>
                        <label for="projectSelect">Project: </label>
                        <select id="projectSelect">
                            <option value="">All Projects</option>
                        </select>
                    </div>
                    <div>
                        <label for="capabilitySelect">Capability: </label>
                        <select id="capabilitySelect">
                            <option value="">All Capabilities</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label for="repulsionForce">Repulsion Force: </label>
                    <input type="range" id="repulsionForce" min="400" max="2000" value="800" style="width: 200px;">
                    <span id="repulsionValue">800</span>
                </div>
            </div>
            <div id="networkContainer" style="width: 100%; height: calc(100% - 50px);"></div>
        </div>
        <div id="rankingsTab" class="tab-content">
            <div class="rankings-container">
                <div class="ranking-section">
                    <h3>Top 10 Projects by Capabilities</h3>
                    <div class="top-projects-list" id="topProjectsByCapabilities"></div>
                </div>
                <div class="ranking-section">
                    <h3>Top 10 Projects by Budget</h3>
                    <div class="top-projects-list" id="topProjectsByBudget"></div>
                </div>
                <div class="ranking-section">
                    <h3>Top 10 Most Impacted Teams</h3>
                    <div class="top-projects-list" id="topTeamsByProjects"></div>
                </div>
            </div>
        </div>
        <div id="ganttTab" class="tab-content">
            <div id="ganttContainer" style="width: 100%; height: calc(100vh - 200px);"></div>
        </div>
        <div id="resourcesTab" class="tab-content">
            <div class="resource-charts-container">
                <div id="resourceHeatmapChart" style="width: 100%; height: 600px;"></div>
            </div>
        </div>
    </div>

    <button class="menu-button">☰ Menu</button>
    <div class="menu">
        <div class="menu-item" onclick="showHowTo()">How to Use</div>
        <div class="menu-item" onclick="showAbout()">About</div>
    </div>

    <div class="dialog-overlay">
        <div class="dialog">
            <button class="dialog-close" onclick="hideDialog()">×</button>
            <h2>How to Use This Tool</h2>
            
            <h3>Overview</h3>
            <p>This application is designed for Enterprise Architects and Portfolio Managers to assess the impact of programs and projects across the enterprise portfolio. It provides both quick assessments and detailed architectural insights through various visualizations.</p>

            <h3>Getting Started</h3>
            <ol>
                <li><strong>Load Project Files:</strong>
                    <ul>
                        <li>Click "Choose Files" under "Project Files"</li>
                        <li>Select one or multiple Excel files containing program/project data</li>
                    </ul>
                </li>
                <li><strong>Load Team Mapping (Optional):</strong>
                    <ul>
                        <li>Click "Choose File" under "Team Mapping File"</li>
                        <li>Select the Excel file containing team-to-capability mappings</li>
                    </ul>
                </li>
                <li><strong>Load Resource Files (Optional):</strong>
                    <ul>
                        <li>Click "Choose Files" under "Resource Files"</li>
                        <li>Select one or multiple Excel files containing project resource allocations</li>
                        <li>Resource files provide insights into human resource distribution and effort estimation</li>
                    </ul>
                </li>
            </ol>

            <h3>Available Views</h3>
            <ul>
                <li><strong>Capability Heatmap:</strong> Shows capability impact density across programs</li>
                <li><strong>Dependency Flow:</strong> Visualizes team and capability relationships (requires team mapping)</li>
                <li><strong>Program Hierarchy:</strong> Displays program structure and relationships</li>
                <li><strong>Estimated Budgets:</strong> Shows budget distribution across programs and projects</li>
                <li><strong>Program Dependencies:</strong> Highlights shared capabilities between programs</li>
                <li><strong>Program-Capability Network:</strong> Interactive network view of all relationships</li>
                <li><strong>Resource Allocation:</strong> Displays resource distribution across programs by job function</li>
            </ul>

            <h3>Resource Allocation Insights</h3>
            <ul>
                <li><strong>Resource Heatmap:</strong> Visual representation of resource distribution showing:
                    <ul>
                        <li>Job function concentration across programs</li>
                        <li>Resource allocation patterns</li>
                        <li>Potential resource bottlenecks</li>
                    </ul>
                </li>
                <li><strong>Resource Metrics:</strong>
                    <ul>
                        <li>Total Resources: Overall count of allocated resources</li>
                        <li>Average Resources per Project: Resource distribution ratio</li>
                        <li>Total Estimated Man/Days: Cumulative effort estimation</li>
                    </ul>
                </li>
            </ul>

            <h3>Features</h3>
            <ul>
                <li><strong>Period Filtering:</strong> Filter data by quarter or month</li>
                <li><strong>Interactive Visualizations:</strong> Hover for details, zoom, and pan</li>
                <li><strong>Metrics Dashboard:</strong> Key statistics and portfolio overview</li>
                <li><strong>Resource Analytics:</strong> Human resource allocation analysis and effort estimation</li>
            </ul>

            <h3>Tips</h3>
            <ul>
                <li>Use the period filter to focus on specific timeframes</li>
                <li>Hover over visualizations for detailed information</li>
                <li>Switch between views using the tab navigation</li>
                <li>Monitor resource distribution patterns to identify potential staffing issues</li>
                <li>Use the resource heatmap to optimize job function allocation across programs</li>
            </ul>

            <h3>Sample Files</h3>
            <p>You can generate sample files using our generators:</p>
            <ul>
                <li><code>node generate-program.js</code> - Generates program/project files</li>
                <li><code>node generate-team-to-capabilities.js</code> - Generates team mapping file</li>
            </ul>

            <h3>File Formats</h3>
            <div class="file-format">
                <strong>Program/Project Files (Excel):</strong>
                <ul>
                    <li>Program Name</li>
                    <li>Project Name</li>
                    <li>Phase (Initiation/Intake)</li>
                    <li>Capability Domain (Business/IT)</li>
                    <li>Capability Name</li>
                    <li>Action (Create/Update/Delete)</li>
                    <li>Delivery Period (YYYY-QN)</li>
                    <li>Architect</li>
                    <li>Total Cost Estimation (€)</li>
                </ul>
            </div>
            <div class="file-format">
                <strong>Team Mapping File (Excel):</strong>
                <ul>
                    <li>Team Name</li>
                    <li>Capability Domain (Business/IT)</li>
                    <li>Capability Name</li>
                </ul>
            </div>

            <h3>Project Phases and Progress</h3>
            <p>The Delivery Timeline tab shows project progress based on their current phase:</p>
            <ul>
                <li>Ideation: 10% completion</li>
                <li>Intake: 20% completion</li>
                <li>Initiation: 30% completion</li>
                <li>Implementation: 50% completion</li>
                <li>User Acceptance: 80% completion</li>
                <li>Production: 100% completion</li>
            </ul>
        </div>
    </div>

    <div class="dialog-overlay" id="aboutDialog">
        <div class="dialog">
            <button class="dialog-close" onclick="hideAbout()">×</button>
            <h2>About</h2>
            <div style="text-align: center; margin: 20px 0;">
                <h3 style="margin-bottom: 5px;">Enterprise Architecture - Capabilities Delivery Flow</h3>
                <p style="color: #666; margin-bottom: 20px;">Version 0.1.0</p>
                <p>Created by</p>
                <h3 style="margin: 5px 0;">
                    <a href="https://yannickhuchard.com" target="_blank" style="color: #007bff; text-decoration: none;">
                        Yannick HUCHARD
                    </a>
                </h3>
            </div>
        </div>
    </div>

    <script>
        let allData = [];
        let teamMappings = [];
        let myChart = null;
        let sankeyChart = null;
        let circlePackingChart = null;
        let dependenciesChart = null;
        let networkChart = null;
        let sankeyZoomLevel = 1;
        let coachMarkTimeout = null;
        let ganttChart = null;
        // Resource allocation state
        const resourceState = {
            chart: null,
            data: [],
            initialized: false
        };

        document.getElementById('xlsxInput').addEventListener('change', handleFile);
        document.getElementById('teamMappingInput').addEventListener('change', handleTeamMapping);
        document.getElementById('resourcesInput').addEventListener('change', handleResourceFiles);
        document.getElementById('periodType').addEventListener('change', updatePeriodSelect);
        document.getElementById('periodSelect').addEventListener('change', updateVisualizations);

        // Update the tab switching event listeners
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Update button states
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.tab-content').forEach(tab => {
                    if (tab) tab.style.display = 'none';
                });
                const targetTab = document.getElementById(`${button.dataset.tab}Tab`);
                if (targetTab) targetTab.style.display = 'block';
                
                // Trigger resize for the visible chart
                setTimeout(() => {
                    if (button.dataset.tab === 'heatmap' && myChart) {
                        myChart.resize();
                    } else if (button.dataset.tab === 'sankey' && sankeyChart) {
                        sankeyChart.resize();
                    } else if (button.dataset.tab === 'hierarchy' && circlePackingChart) {
                        circlePackingChart.resize();
                    } else if (button.dataset.tab === 'budget') {
                        const budgetCharts = document.querySelectorAll('#budgetContainer > div');
                        budgetCharts.forEach(div => {
                            const chart = echarts.getInstanceByDom(div);
                            if (chart) chart.resize();
                        });
                    } else if (button.dataset.tab === 'dependencies' && dependenciesChart) {
                        dependenciesChart.resize();
                    } else if (button.dataset.tab === 'network' && networkChart) {
                        networkChart.resize();
                    } else if (button.dataset.tab === 'gantt' && ganttChart) {
                        ganttChart.resize();
                    } else if (button.dataset.tab === 'resourcesTab') {
                        if (!resourceState.initialized) {
                            setupResourceHeatmap();
                        }
                        if (resourceState.data.length > 0) {
                            renderResourceHeatmap();
                        }
                    }
                }, 50);
            });
        });

        // Update initial tab visibility
        document.getElementById('heatmapTab').style.display = 'block';
        document.querySelectorAll('.tab-content').forEach(tab => {
            if (tab.id !== 'heatmapTab') {
                tab.style.display = 'none';
            }
        });

        function handleFile(e) {
            allData = [];
            const files = Array.from(e.target.files);
            let filesProcessed = 0;
            
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    workbook.SheetNames.forEach(sheetName => {
                        const sheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(sheet);
                        allData = allData.concat(jsonData);
                    });
                    
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        updatePeriodSelect();
                        updateVisualizations();
                        updateMetrics();
                        updateGanttChart();
                        updateCoachMarks();
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function handleTeamMapping(e) {
            teamMappings = [];
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    teamMappings = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
                    updateVisualizations();
                    updateMetrics();
                    updateCoachMarks();
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function handleResourceFiles(e) {
            const files = e.target.files;
            resourceState.data = [];
            
            let filesProcessed = 0;
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const sheetName = workbook.SheetNames[0];
                    const sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                    resourceState.data.push(...sheetData);
                    
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        console.log(`Loaded ${resourceState.data.length} resource records`);
                        updateResourceMetrics();
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function updateVisualizations() {
            if (allData.length > 0) {
                updateChart();
                updateCirclePacking();
                updateBudgetCharts();
                updateProgramDependencies();
                updateProgramCapabilityNetwork();
                const budgetBtn = document.querySelector('[data-tab="budget"]');
                const dependenciesBtn = document.querySelector('[data-tab="dependencies"]');
                const networkBtn = document.querySelector('[data-tab="network"]');
                if (budgetBtn) budgetBtn.style.display = 'block';
                if (dependenciesBtn) dependenciesBtn.style.display = 'block';
                if (networkBtn) networkBtn.style.display = 'block';
            } else {
                const budgetBtn = document.querySelector('[data-tab="budget"]');
                const dependenciesBtn = document.querySelector('[data-tab="dependencies"]');
                const networkBtn = document.querySelector('[data-tab="network"]');
                if (budgetBtn) budgetBtn.style.display = 'none';
                if (dependenciesBtn) dependenciesBtn.style.display = 'none';
                if (networkBtn) networkBtn.style.display = 'none';
            }
            
            if (allData.length > 0 && teamMappings.length > 0) {
                updateSankeyDiagram();
                const sankeyBtn = document.querySelector('[data-tab="sankey"]');
                if (sankeyBtn) sankeyBtn.style.display = 'block';
            } else {
                const sankeyBtn = document.querySelector('[data-tab="sankey"]');
                if (sankeyBtn) sankeyBtn.style.display = 'none';
            }
        }

        function updatePeriodSelect() {
            const periodType = document.getElementById('periodType').value;
            const select = document.getElementById('periodSelect');
            select.disabled = periodType === 'all';
            
            const periods = Array.from(new Set(allData.map(d => {
                const period = d['Delivery Period'];
                if(periodType === 'quarter') return period.split('-')[0] ? period : `${new Date(period).getFullYear()}-Q${Math.ceil((new Date(period).getMonth()+1)/3)}`;
                if(periodType === 'month') return period.includes('/') ? period : `${String(new Date(period).getMonth()+1).padStart(2,'0')}/${new Date(period).getFullYear()}`;
                return 'all';
            }))).sort();

            select.innerHTML = periodType === 'all' 
                ? '<option value="all">All</option>' 
                : '<option value="all">All</option>' + periods.map(p => `<option value="${p}">${p}</option>`).join('');
        }

        function updateChart() {
            const filteredData = filterData();
            const processed = processData(filteredData);
            if(!myChart) myChart = echarts.init(document.getElementById('chartContainer'));
            
            const showProjects = document.getElementById('viewToggle').checked;
            
            const option = {
                tooltip: {
                    formatter: params => {
                        if (showProjects) {
                            const project = processed.programs[params.data[0]];
                            const details = processed.detailsMap.get(`${params.data[0]}-${params.data[1]}`);
                            return `
                                <strong>${details[0]}</strong><br>
                                ${details[1]}<br>
                                ${processed.capabilities[params.data[1]]}<br>
                                Dependencies: ${params.data[2]}
                            `;
                        } else {
                            return `
                        <strong>${processed.programs[params.data[0]]}</strong><br>
                        ${processed.capabilities[params.data[1]]}<br>
                        Dependencies: ${params.data[2]}<br>
                                Projects:<br/>${processed.detailsMap.get(`${params.data[0]}-${params.data[1]}`).map(p => `• ${p}`).join('<br/>')}<br/>
                                Program: ${processed.programs[params.data[0]]}
                            `;
                        }
                    }
                },
                grid: {
                    top: 50,
                    right: 100,
                    bottom: 150,
                    left: 200
                },
                xAxis: { 
                    type: 'category', 
                    data: processed.programs,
                    axisLabel: { 
                        rotate: 45,
                        interval: 0,
                        formatter: value => {
                            if (showProjects) {
                                return value.length > 30 ? value.substring(0, 30) + '...' : value;
                            }
                            return value.length > 20 ? value.substring(0, 20) + '...' : value;
                        },
                        overflow: 'break',
                        lineHeight: 20
                    }
                },
                yAxis: { 
                    type: 'category',
                    data: processed.capabilities,
                    axisLabel: {
                        interval: 0,
                        formatter: value => {
                            return value.length > 40 ? value.substring(0, 40) + '...' : value;
                        }
                    }
                },
                visualMap: {
                    min: 0,
                    max: Math.max(...processed.matrix.map(m => m[2])),
                    calculable: true,
                    inRange: { color: ['#ffffff', '#98fb98', '#f0e68c', '#ffb6c1', '#cd5c5c'] }
                },
                series: [{
                    type: 'heatmap',
                    data: processed.matrix.map(m => [m[0], m[1], m[2]]),
                    label: { 
                        show: true, 
                        formatter: params => params.data[2] > 0 ? params.data[2] : '' 
                    }
                }]
            };
            
            myChart.setOption(option);
            myChart.resize();
        }

        function filterData() {
            const periodType = document.getElementById('periodType').value;
            const period = document.getElementById('periodSelect').value;
            return allData.filter(d => {
                if(periodType === 'all') return true;
                const dp = d['Delivery Period'];
                const currentPeriod = periodType === 'quarter' 
                    ? dp.includes('Q') ? dp : `${new Date(dp).getFullYear()}-Q${Math.ceil((new Date(dp).getMonth()+1)/3)}`
                    : dp.includes('/') ? dp : `${String(new Date(dp).getMonth()+1).padStart(2,'0')}/${new Date(dp).getFullYear()}`;
                return currentPeriod === period;
            });
        }

        function processData(data) {
            const showProjects = document.getElementById('viewToggle').checked;
            
            if (showProjects) {
                const projects = [...new Set(data.map(d => d['Project Name']))];
                const capabilities = [...new Set(data.map(d => `${d['Capability Domain']}: ${d['Capability Name']}`))];
                const matrix = [];
                const detailsMap = new Map();
                const projectPrograms = new Map();

                // Create project to program mapping
                data.forEach(d => {
                    projectPrograms.set(d['Project Name'], d['Program Name']);
                });

                projects.forEach((project, pIdx) => {
                    capabilities.forEach((capability, cIdx) => {
                        const entries = data.filter(d => 
                            d['Project Name'] === project && 
                            `${d['Capability Domain']}: ${d['Capability Name']}` === capability
                        );
                        if(entries.length) {
                            matrix.push([pIdx, cIdx, entries.length]);
                            // Include both project name and program name in detailsMap
                            detailsMap.set(`${pIdx}-${cIdx}`, [
                                `${project}`,
                                `Program: ${projectPrograms.get(project)}`
                            ]);
                        }
                    });
                });

                return { 
                    programs: projects, 
                    capabilities, 
                    matrix, 
                    detailsMap,
                    projectPrograms 
                };
            } else {
                // Existing program view logic
            const programs = [...new Set(data.map(d => d['Program Name']))];
            const capabilities = [...new Set(data.map(d => `${d['Capability Domain']}: ${d['Capability Name']}`))];
            const matrix = [];
            const detailsMap = new Map();

            programs.forEach((program, pIdx) => {
                capabilities.forEach((capability, cIdx) => {
                    const entries = data.filter(d => 
                        d['Program Name'] === program && 
                        `${d['Capability Domain']}: ${d['Capability Name']}` === capability
                    );
                    if(entries.length) {
                        matrix.push([pIdx, cIdx, entries.length]);
                        detailsMap.set(`${pIdx}-${cIdx}`, entries.map(e => e['Project Name']));
                    }
                });
            });

            return { programs, capabilities, matrix, detailsMap };
        }
        }

        function updateSankeyDiagram() {
            const filteredData = filterData();
            if (!sankeyChart) sankeyChart = echarts.init(document.getElementById('sankeyContainer'));

            // Prepare nodes and links for Sankey diagram
            const nodes = [];
            const links = [];
            const nodeMap = new Map();

            // Helper function to add node and get its index
            function addNode(name, category) {
                const key = `${category}:${name}`;
                if (!nodeMap.has(key)) {
                    nodeMap.set(key, nodes.length);
                    nodes.push({ name: name, category: category });
                }
                return nodeMap.get(key);
            }

            // Add program nodes and project links
            filteredData.forEach(project => {
                const programIdx = addNode(project['Program Name'], 'program');
                const projectIdx = addNode(project['Project Name'], 'project');
                const capabilityIdx = addNode(
                    `${project['Capability Domain']}: ${project['Capability Name']}`,
                    'capability'
                );

                // Program to Project link
                links.push({
                    source: programIdx,
                    target: projectIdx,
                    value: 1
                });

                // Project to Capability link
                links.push({
                    source: projectIdx,
                    target: capabilityIdx,
                    value: 1
                });

                // Find team for this capability and add link
                const teamMapping = teamMappings.find(tm => 
                    tm['Capability Domain'] === project['Capability Domain'] &&
                    tm['Capability Name'] === project['Capability Name']
                );

                if (teamMapping) {
                    const teamIdx = addNode(teamMapping['Team Name'], 'team');
                    links.push({
                        source: capabilityIdx,
                        target: teamIdx,
                        value: 1
                    });
                }
            });

            const option = {
                title: {
                    text: 'Program to Team Dependencies',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'item',
                    triggerOn: 'mousemove'
                },
                series: [{
                    type: 'sankey',
                    data: nodes,
                    links: links,
                    nodeWidth: Math.round(20 * sankeyZoomLevel),
                    nodeGap: Math.round(8 * sankeyZoomLevel),
                    emphasis: {
                        focus: 'adjacency'
                    },
                    levels: [
                        { depth: 0, itemStyle: { color: '#e31a1c' } },  // Programs
                        { depth: 1, itemStyle: { color: '#33a02c' } },  // Projects
                        { depth: 2, itemStyle: { color: '#1f78b4' } },  // Capabilities
                        { depth: 3, itemStyle: { color: '#6a3d9a' } }   // Teams
                    ],
                    lineStyle: {
                        color: 'gradient',
                        curveness: 0.5
                    },
                    label: {
                        position: 'right'
                    }
                }]
            };

            sankeyChart.setOption(option);
            window.addEventListener('resize', () => sankeyChart.resize());
        }

        function updateCirclePacking() {
            const filteredData = filterData();
            if (!circlePackingChart) {
                circlePackingChart = echarts.init(document.getElementById('circlePackingContainer'));
            }

            // Prepare hierarchical data
            const hierarchyData = {
                name: 'root',
                children: []
            };

            // Group by programs
            const programGroups = new Map();
            filteredData.forEach(item => {
                if (!programGroups.has(item['Program Name'])) {
                    programGroups.set(item['Program Name'], new Map());
                }
                const projectMap = programGroups.get(item['Program Name']);
                
                if (!projectMap.has(item['Project Name'])) {
                    projectMap.set(item['Project Name'], new Set());
                }
                projectMap.get(item['Project Name']).add(
                    `${item['Capability Domain']}: ${item['Capability Name']}`
                );
            });

            // Build hierarchy
            programGroups.forEach((projectMap, programName) => {
                const programNode = {
                    name: programName,
                    value: 1,
                    children: []
                };

                projectMap.forEach((capabilities, projectName) => {
                    const projectNode = {
                        name: projectName,
                        value: 1,
                        children: Array.from(capabilities).map(cap => ({
                            name: cap,
                            value: 1
                        }))
                    };
                    programNode.children.push(projectNode);
                });

                hierarchyData.children.push(programNode);
            });

            const option = {
                title: {
                    text: 'Program Hierarchy',
                    left: 'center'
                },
                tooltip: {
                    formatter: (params) => {
                        const data = params.data;
                        const value = data.value;
                        if (data.children) {
                            const childCount = data.children.length;
                            return `${data.name}<br/>Contains: ${childCount} ${
                                data.children[0].children ? 'Projects' : 'Capabilities'
                            }`;
                        }
                        return data.name;
                    }
                },
                series: {
                    type: 'treemap',
                    layoutAlgorithm: 'squarified',
                    nodeClick: false,
                    roam: false,
                    width: '100%',
                    height: '100%',
                    data: [hierarchyData],
                    levels: [
                        {
                            itemStyle: {
                                borderColor: '#555',
                                borderWidth: 4,
                                gapWidth: 4
                            }
                        },
                        {
                            itemStyle: {
                                borderColor: '#333',
                                borderWidth: 3,
                                gapWidth: 3
                            }
                        },
                        {
                            itemStyle: {
                                borderColor: '#222',
                                borderWidth: 2,
                                gapWidth: 2
                            }
                        }
                    ],
                    label: {
                        show: true
                    },
                    upperLabel: {
                        show: true,
                        height: 30
                    }
                }
            };

            circlePackingChart.setOption(option);
            window.addEventListener('resize', () => circlePackingChart.resize());
        }

        function updateBudgetCharts() {
            const budgetContainer = document.getElementById('budgetContainer');
            // Clear existing charts properly
            const existingCharts = document.querySelectorAll('#budgetContainer > div');
            existingCharts.forEach(div => {
                const chart = echarts.getInstanceByDom(div);
                if (chart) {
                    chart.dispose();
                }
            });
            budgetContainer.innerHTML = '';
            budgetContainer.style.display = 'flex';
            budgetContainer.style.flexDirection = 'column';
            budgetContainer.style.alignItems = 'center';
            budgetContainer.style.overflowY = 'auto';

            // Group data by program
            const programData = new Map();
            allData.forEach(item => {
                if (!programData.has(item['Program Name'])) {
                    programData.set(item['Program Name'], new Map());
                }
                const projectMap = programData.get(item['Program Name']);
                
                if (!projectMap.has(item['Project Name'])) {
                    // Fix budget parsing: remove € symbol, replace dots, then parse
                    const budget = item['Total Cost Estimation'] ? 
                        parseInt(item['Total Cost Estimation']
                            .replace('€', '')
                            .replace(/\./g, '')
                            .replace(',', '.')) : 0;
                            
                    projectMap.set(item['Project Name'], {
                        count: 0,
                        budget: budget
                    });
                }
                projectMap.get(item['Project Name']).count++;
            });

            // Create a chart for each program
            programData.forEach((projectMap, programName) => {
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '90%';
                chartDiv.style.height = '600px';
                chartDiv.style.marginBottom = '30px';
                budgetContainer.appendChild(chartDiv);

                const chart = echarts.init(chartDiv);

                const projects = Array.from(projectMap.entries());
                const projectNames = projects.map(([name]) => name);
                const projectCounts = projects.map(([_, data]) => data.count);
                const projectBudgets = projects.map(([_, data]) => data.budget);
                
                // Calculate total budget for percentage
                const totalBudget = projectBudgets.reduce((a, b) => a + b, 0);

                const option = {
                    title: {
                        text: programName,
                        left: 'center',
                        top: 20,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: (params) => {
                            if (params.seriesIndex === 0) {
                                return `${params.name}<br/>Capabilities: ${params.value}`;
                            } else {
                                const percentage = ((params.value / totalBudget) * 100).toFixed(1);
                                return `${params.name}<br/>Budget: €${params.value.toLocaleString('de-DE')} (${percentage}%)`;
                            }
                        }
                    },
                    legend: {
                        type: 'scroll',
                        orient: 'vertical',
                        right: '5%',
                        top: 'middle',
                        data: projectNames
                    },
                    series: [
                        {
                            name: 'Capabilities',
                            type: 'pie',
                            selectedMode: 'single',
                            radius: [0, '30%'],
                            center: ['40%', '50%'],
                            label: {
                                position: 'inner',
                                fontSize: 14,
                                formatter: '{b}\n{c}'
                            },
                            labelLine: {
                                show: false
                            },
                            data: projectNames.map((name, i) => ({
                                name: name,
                                value: projectCounts[i]
                            }))
                        },
                        {
                            name: 'Budget',
                            type: 'pie',
                            radius: ['45%', '60%'],
                            center: ['40%', '50%'],
                            labelLine: {
                                length: 30
                            },
                            label: {
                                formatter: (params) => {
                                    const percentage = ((params.value / totalBudget) * 100).toFixed(1);
                                    return `${params.name}\n€${params.value.toLocaleString('de-DE')}\n${percentage}%`;
                                },
                                backgroundColor: '#F6F8FC',
                                borderColor: '#8C8D8E',
                                borderWidth: 1,
                                borderRadius: 4,
                                padding: [4, 8],
                                rich: {
                                    b: {
                                        color: '#4C5058',
                                        fontSize: 14,
                                        fontWeight: 'bold',
                                        lineHeight: 22
                                    },
                                    per: {
                                        color: '#fff',
                                        backgroundColor: '#4C5058',
                                        padding: [2, 4],
                                        borderRadius: 4
                                    }
                                }
                            },
                            data: projectNames.map((name, i) => ({
                                name: name,
                                value: projectBudgets[i]
                            }))
                        }
                    ]
                };

                chart.setOption(option);
                
                // Ensure chart resizes properly when container becomes visible
                const resizeObserver = new ResizeObserver(() => {
                    chart.resize();
                });
                resizeObserver.observe(chartDiv);
            });
        }

        function updateProgramDependencies() {
            if (!dependenciesChart) {
                dependenciesChart = echarts.init(document.getElementById('dependenciesContainer'));
            }

            // Get all programs and assign colors
            const programs = [...new Set(allData.map(d => d['Program Name']))];
            const colors = [
                '#ff7f50', '#87cefa', '#da70d6', '#32cd32', '#6495ed',
                '#ff69b4', '#ba55d3', '#cd5c5c', '#ffa500', '#40e0d0'
            ];
            const programColors = Object.fromEntries(
                programs.map((prog, i) => [prog, colors[i % colors.length]])
            );

            // Create capability map for each program
            const programCapabilities = new Map();
            allData.forEach(item => {
                if (!programCapabilities.has(item['Program Name'])) {
                    programCapabilities.set(item['Program Name'], new Set());
                }
                programCapabilities.get(item['Program Name']).add(
                    `${item['Capability Domain']}:${item['Capability Name']}`
                );
            });

            // Calculate shared capabilities between programs
            const links = [];
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    const prog1 = programs[i];
                    const prog2 = programs[j];
                    const caps1 = programCapabilities.get(prog1);
                    const caps2 = programCapabilities.get(prog2);
                    const shared = new Set([...caps1].filter(x => caps2.has(x)));
                    
                    if (shared.size > 0) {
                        links.push({
                            source: prog1,
                            target: prog2,
                            value: shared.size,
                            capabilities: Array.from(shared)
                        });
                    }
                }
            }

            const option = {
                title: {
                    text: 'Program Dependencies (Shared Capabilities)',
                    left: 'center',
                    top: 20
                },
                tooltip: {
                    trigger: 'item',
                    formatter: (params) => {
                        if (params.dataType === 'edge') {
                            return `${params.data.source} ↔ ${params.data.target}<br/>` +
                                   `Shared Capabilities: ${params.data.value}<br/>` +
                                   params.data.capabilities.map(cap => 
                                       `• ${cap.replace(':', ': ')}`
                                   ).join('<br/>');
                        }
                        return params.name;
                    }
                },
                legend: {
                    data: programs,
                    orient: 'vertical',
                    right: 20,
                    top: 'middle',
                    formatter: (name) => {
                        const count = programCapabilities.get(name).size;
                        return `${name} (${count} capabilities)`;
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'circular',
                    data: programs.map(prog => ({
                        name: prog,
                        itemStyle: {
                            color: programColors[prog]
                        }
                    })),
                    links: links,
                    lineStyle: {
                        width: 2,
                        curveness: 0.3,
                        opacity: 0.7
                    },
                    emphasis: {
                        focus: 'adjacency',
                        lineStyle: {
                            width: 4
                        }
                    }
                }]
            };

            dependenciesChart.setOption(option);
            window.addEventListener('resize', () => dependenciesChart.resize());
        }

        function updateProgramCapabilityNetwork() {
            if (!networkChart) {
                networkChart = echarts.init(document.getElementById('networkContainer'));
            }

            // Vivid colors for programs
            const programColors = {
                'Regulatory Program': '#FF0000',      // Vivid Red
                'Digital Program': '#00FF00',         // Vivid Green
                'IT Core Program': '#0066FF',         // Vivid Blue
                'Innovation Program': '#FF00FF',      // Vivid Magenta
                'Credit Program': '#FFD700',          // Gold
                'Market Mandatory Program': '#FF6600', // Vivid Orange
                'KYC-KYT Program': '#9933FF',         // Vivid Purple
                'Data Program': '#00FFFF'             // Cyan
            };

            // Prepare nodes and links
            const nodes = [];
            const links = [];
            const nodeMap = new Map();

            // First pass: collect all unique elements and their counts
            const programProjects = new Map();
            const projectCapabilities = new Map();
            const capabilityRelations = new Map();

            allData.forEach(item => {
                // Program-Project relationship
                if (!programProjects.has(item['Program Name'])) {
                    programProjects.set(item['Program Name'], new Set());
                }
                programProjects.get(item['Program Name']).add(item['Project Name']);

                // Project-Capability relationship
                if (!projectCapabilities.has(item['Project Name'])) {
                    projectCapabilities.set(item['Project Name'], new Set());
                }
                const capKey = `${item['Capability Domain']}: ${item['Capability Name']}`;
                projectCapabilities.get(item['Project Name']).add(capKey);

                // Capability relations count
                capabilityRelations.set(capKey, (capabilityRelations.get(capKey) || 0) + 1);
            });

            // Add program nodes
            programProjects.forEach((projects, program) => {
                nodes.push({
                    name: program,
                    value: projects.size,
                    category: 'Program',
                    symbolSize: Math.max(50, Math.min(100, projects.size * 6)),
                    itemStyle: {
                        color: programColors[program]
                    },
                    label: {
                        show: true,
                        formatter: (params) => `${params.name}\n(${params.value} projects)`,
                        fontSize: 14,
                        fontWeight: 'bold'
                    }
                });
                nodeMap.set(program, nodes.length - 1);
            });

            // Add project nodes
            projectCapabilities.forEach((capabilities, project) => {
                const program = allData.find(item => item['Project Name'] === project)['Program Name'];
                nodes.push({
                    name: project,
                    value: capabilities.size,
                    category: 'Project',
                    symbolSize: Math.max(30, Math.min(70, capabilities.size * 4)),
                    itemStyle: {
                        color: programColors[program]  // Inherit program color
                    },
                    label: {
                        show: true,
                        formatter: (params) => `${params.name}\n(${params.value} capabilities)`,
                        fontSize: 12
                    }
                });
                nodeMap.set(project, nodes.length - 1);

                // Create Program-Project link
                links.push({
                    source: nodeMap.get(program),
                    target: nodeMap.get(project),
                    value: 1,
                    lineStyle: {
                        color: programColors[program]
                    }
                });
            });

            // Add capability nodes and create Project-Capability links
            const processedLinks = new Set();
            allData.forEach(item => {
                const capKey = `${item['Capability Domain']}: ${item['Capability Name']}`;
                if (!nodeMap.has(capKey)) {
                    const relationCount = capabilityRelations.get(capKey);
                    nodes.push({
                        name: capKey,
                        value: relationCount,
                        category: 'Capability',
                        symbolSize: Math.max(20, Math.min(60, relationCount * 3)),
                        itemStyle: {
                            color: '#A0A0A0'  // Gray for capabilities
                        },
                        label: {
                            show: true,
                            formatter: (params) => `${params.name}\n(${params.value} relations)`,
                            fontSize: 12
                        }
                    });
                    nodeMap.set(capKey, nodes.length - 1);
                }

                // Create Project-Capability link
                const linkKey = `${item['Project Name']}-${capKey}`;
                if (!processedLinks.has(linkKey)) {
                    const program = item['Program Name'];
                    links.push({
                        source: nodeMap.get(item['Project Name']),
                        target: nodeMap.get(capKey),
                        value: 1,
                        lineStyle: {
                            color: programColors[program],
                            opacity: 0.6
                        }
                    });
                    processedLinks.add(linkKey);
                }
            });

            // Populate selectors
            const programSelect = document.getElementById('programSelect');
            const projectSelect = document.getElementById('projectSelect');
            const capabilitySelect = document.getElementById('capabilitySelect');

            // Clear and populate program selector
            programSelect.innerHTML = '<option value="">All Programs</option>' +
                Array.from(programProjects.keys())
                    .map(prog => `<option value="${prog}">${prog}</option>`)
                    .join('');

            // Clear and populate project selector
            projectSelect.innerHTML = '<option value="">All Projects</option>' +
                Array.from(projectCapabilities.keys())
                    .map(proj => `<option value="${proj}">${proj}</option>`)
                    .join('');

            // Clear and populate capability selector
            capabilitySelect.innerHTML = '<option value="">All Capabilities</option>' +
                Array.from(capabilityRelations.keys())
                    .map(cap => `<option value="${cap}">${cap}</option>`)
                    .join('');

            function updateChart(repulsionValue) {
                const selectedProgram = programSelect.value;
                const selectedProject = projectSelect.value;
                const selectedCapability = capabilitySelect.value;

                // Calculate highlighted nodes and links
                const highlightedNodes = new Set();
                const highlightedLinks = new Set();

                if (selectedProgram || selectedProject || selectedCapability) {
                    nodes.forEach((node, idx) => {
                        if ((selectedProgram && node.name === selectedProgram) ||
                            (selectedProject && node.name === selectedProject) ||
                            (selectedCapability && node.name === selectedCapability)) {
                            highlightedNodes.add(idx);
                            // Add connected nodes
                            links.forEach((link, linkIdx) => {
                                if (link.source === idx) {
                                    highlightedNodes.add(link.target);
                                    highlightedLinks.add(linkIdx);
                                } else if (link.target === idx) {
                                    highlightedNodes.add(link.source);
                                    highlightedLinks.add(linkIdx);
                                }
                            });
                        }
                    });
                }

                const option = {
                    title: {
                        text: 'Program-Project-Capability Network',
                        left: 'center',
                        top: 20
                    },
                    tooltip: {
                        formatter: (params) => {
                            if (params.dataType === 'node') {
                                const category = params.data.category;
                                if (category === 'Program') {
                                    return `${params.name}<br/>${params.value} projects`;
                                } else if (category === 'Project') {
                                    return `${params.name}<br/>${params.value} capabilities`;
                                } else {
                                    return `${params.name}<br/>${params.value} relations`;
                                }
                            }
                            return `${params.data.source} → ${params.data.target}`;
                        }
                    },
                    legend: {
                        data: ['Program', 'Project', 'Capability'],
                        orient: 'vertical',
                        right: 20,
                        top: 'middle'
                    },
                    series: [{
                        type: 'graph',
                        layout: 'force',
                        data: nodes.map((node, idx) => ({
                            ...node,
                            itemStyle: {
                                ...node.itemStyle,
                                opacity: highlightedNodes.size === 0 || highlightedNodes.has(idx) ? 1 : 0.1
                            },
                            label: {
                                ...node.label,
                                show: highlightedNodes.size === 0 || highlightedNodes.has(idx)
                            }
                        })),
                        links: links.map((link, idx) => ({
                            ...link,
                            lineStyle: {
                                ...link.lineStyle,
                                opacity: highlightedLinks.size === 0 || highlightedLinks.has(idx) ? 0.6 : 0.1
                            }
                        })),
                        categories: [
                            { name: 'Program' },
                            { name: 'Project' },
                            { name: 'Capability' }
                        ],
                        roam: true,
                        draggable: true,
                        force: {
                            repulsion: repulsionValue,
                            edgeLength: 300,
                            gravity: 0.1
                        },
                        emphasis: {
                            focus: 'adjacency',
                            lineStyle: {
                                width: 4
                            }
                        }
                    }]
                };

                networkChart.setOption(option);
            }

            // Add event listeners for selectors
            programSelect.addEventListener('change', () => updateChart(parseInt(document.getElementById('repulsionForce').value)));
            projectSelect.addEventListener('change', () => updateChart(parseInt(document.getElementById('repulsionForce').value)));
            capabilitySelect.addEventListener('change', () => updateChart(parseInt(document.getElementById('repulsionForce').value)));

            // Initial chart update
            updateChart(800);

            document.getElementById('repulsionForce').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('repulsionValue').textContent = value;
                updateChart(value);
            });

            window.addEventListener('resize', () => networkChart.resize());
        }

        function zoomSankey(factor) {
            sankeyZoomLevel *= factor;
            sankeyZoomLevel = Math.max(0.5, Math.min(2, sankeyZoomLevel)); // Limit zoom between 0.5x and 2x
            
            if (sankeyChart) {
                const option = sankeyChart.getOption();
                option.series[0].nodeWidth = Math.round(20 * sankeyZoomLevel);
                option.series[0].nodeGap = Math.round(8 * sankeyZoomLevel);
                sankeyChart.setOption(option);
            }
        }

        document.querySelector('.menu-button').addEventListener('click', () => {
            document.querySelector('.menu').classList.toggle('active');
        });

        document.addEventListener('click', (e) => {
            if (!e.target.matches('.menu-button') && !e.target.matches('.menu') && !e.target.matches('.menu-item')) {
                document.querySelector('.menu').classList.remove('active');
            }
        });

        function showHowTo() {
            document.querySelector('.dialog-overlay').style.display = 'block';
            document.querySelector('.menu').classList.remove('active');
        }

        function hideDialog() {
            document.querySelector('.dialog-overlay').style.display = 'none';
        }

        document.querySelector('.dialog-overlay').addEventListener('click', (e) => {
            if (e.target === document.querySelector('.dialog-overlay')) {
                hideDialog();
            }
        });

        function showAbout() {
            document.getElementById('aboutDialog').style.display = 'block';
            document.querySelector('.menu').classList.remove('active');
        }

        function hideAbout() {
            document.getElementById('aboutDialog').style.display = 'none';
        }

        document.querySelectorAll('.dialog-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.style.display = 'none';
                }
            });
        });

        function updateMetrics() {
            // Calculate basic counts
            const programs = new Set(allData.map(item => item['Program Name']));
            const projects = new Set(allData.map(item => item['Project Name']));
            const capabilities = new Set(allData.map(item => `${item['Capability Domain']}: ${item['Capability Name']}`));
            const teams = new Set(teamMappings.map(item => item['Team Name']));

            // Calculate project capabilities
            const projectCapabilities = new Map();
            allData.forEach(item => {
                const key = item['Project Name'];
                if (!projectCapabilities.has(key)) {
                    projectCapabilities.set(key, new Set());
                }
                projectCapabilities.get(key).add(`${item['Capability Domain']}: ${item['Capability Name']}`);
            });

            // Calculate program metrics
            const programMetrics = new Map();
            allData.forEach(item => {
                const program = item['Program Name'];
                if (!programMetrics.has(program)) {
                    programMetrics.set(program, {
                        projects: new Set(),
                        capabilities: new Set(),
                        teams: new Set()
                    });
                }
                const metrics = programMetrics.get(program);
                metrics.projects.add(item['Project Name']);
                metrics.capabilities.add(`${item['Capability Domain']}: ${item['Capability Name']}`);
            });

            // Add teams to program metrics if team mapping exists
            if (teamMappings.length > 0) {
                teamMappings.forEach(mapping => {
                    allData.forEach(item => {
                        if (item['Capability Domain'] === mapping['Capability Domain'] &&
                            item['Capability Name'] === mapping['Capability Name']) {
                            const metrics = programMetrics.get(item['Program Name']);
                            if (metrics) {
                                metrics.teams.add(mapping['Team Name']);
                            }
                        }
                    });
                });
            }

            // Calculate averages
            const avgProjectsPerProgram = programs.size ? (projects.size / programs.size).toFixed(1) : '-';
            const avgCapabilitiesPerProgram = programs.size ? (capabilities.size / programs.size).toFixed(1) : '-';
            const avgTeamsPerProgram = programs.size && teams.size ? (teams.size / programs.size).toFixed(1) : '-';

            // Get top 10 projects
            const topProjectsByCapabilities = Array.from(projectCapabilities.entries())
                .map(([name, caps]) => ({ name, count: caps.size }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);

            const topProjectsByBudget = Array.from(new Set(allData.map(item => item['Project Name'])))
                .map(project => {
                    const budget = allData.find(item => item['Project Name'] === project)['Total Cost Estimation'];
                    const parsedBudget = parseInt(budget.replace('€', '').replace(/\./g, '').replace(',', '.'));
                    return {
                        name: project,
                        budget: parsedBudget
                    };
                })
                .filter(project => !isNaN(project.budget))
                .sort((a, b) => b.budget - a.budget)
                .slice(0, 10);

            // Calculate team impact by projects
            const teamProjectsMap = new Map();
            if (teamMappings.length > 0) {
                teamMappings.forEach(mapping => {
                    allData.forEach(item => {
                        if (item['Capability Domain'] === mapping['Capability Domain'] &&
                            item['Capability Name'] === mapping['Capability Name']) {
                            if (!teamProjectsMap.has(mapping['Team Name'])) {
                                teamProjectsMap.set(mapping['Team Name'], new Set());
                            }
                            teamProjectsMap.get(mapping['Team Name']).add(item['Project Name']);
                        }
                    });
                });
            }

            // Get top 10 teams by project count
            const topTeamsByProjects = Array.from(teamProjectsMap.entries())
                .map(([team, projects]) => ({
                    name: team,
                    count: projects.size
                }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);

            // Update DOM with basic metrics
            document.getElementById('programCount').textContent = programs.size;
            document.getElementById('projectCount').textContent = projects.size;
            document.getElementById('capabilityCount').textContent = capabilities.size;
            document.getElementById('teamCount').textContent = teamMappings.length ? teams.size : '-';
            document.getElementById('avgProjectsPerProgram').textContent = avgProjectsPerProgram;
            document.getElementById('avgCapabilitiesPerProgram').textContent = avgCapabilitiesPerProgram;
            document.getElementById('avgTeamsPerProgram').textContent = teamMappings.length ? avgTeamsPerProgram : '-';

            // Update rankings tab
            document.getElementById('topProjectsByCapabilities').innerHTML = topProjectsByCapabilities
                .map((proj, idx) => {
                    let medal = '';
                    let rankClass = '';
                    
                    if (idx === 0) {
                        medal = '🥇';
                        rankClass = 'gold';
                    } else if (idx === 1) {
                        medal = '🥈';
                        rankClass = 'silver';
                    } else if (idx === 2) {
                        medal = '🥉';
                        rankClass = 'bronze';
                    }

                    return `
                        <div class="project-item">
                            <div class="project-rank ${rankClass}">
                                ${medal ? `<span class="medal">${medal}</span>` : `#${idx + 1}`}
                                <span>${proj.name}</span>
                            </div>
                            <div class="project-capabilities">
                                ${proj.count} capabilities
                            </div>
                        </div>
                    `;
                }).join('');

            document.getElementById('topProjectsByBudget').innerHTML = topProjectsByBudget
                .map((proj, idx) => {
                    let medal = '';
                    let rankClass = '';
                    
                    if (idx === 0) {
                        medal = '🥇';
                        rankClass = 'gold';
                    } else if (idx === 1) {
                        medal = '🥈';
                        rankClass = 'silver';
                    } else if (idx === 2) {
                        medal = '🥉';
                        rankClass = 'bronze';
                    }

                    return `
                        <div class="project-item">
                            <div class="project-rank ${rankClass}">
                                ${medal ? `<span class="medal">${medal}</span>` : `#${idx + 1}`}
                                <span>${proj.name}</span>
                            </div>
                            <div class="project-capabilities">
                                ${proj.budget.toLocaleString('de-DE')}
                            </div>
                        </div>
                    `;
                }).join('');

            // Update top teams ranking
            document.getElementById('topTeamsByProjects').innerHTML = topTeamsByProjects
                .map((team, idx) => {
                    let medal = '';
                    let rankClass = '';
                    
                    if (idx === 0) {
                        medal = '🥇';
                        rankClass = 'gold';
                    } else if (idx === 1) {
                        medal = '🥈';
                        rankClass = 'silver';
                    } else if (idx === 2) {
                        medal = '🥉';
                        rankClass = 'bronze';
                    }

                    return `
                        <div class="project-item">
                            <div class="project-rank ${rankClass}">
                                ${medal ? `<span class="medal">${medal}</span>` : `#${idx + 1}`}
                                <span>${team.name}</span>
                            </div>
                            <div class="project-capabilities">
                                ${team.count} projects
                            </div>
                        </div>
                    `;
                }).join('');
        }

        // Update the DOMContentLoaded event handler
        document.addEventListener('DOMContentLoaded', () => {
            if (allData.length === 0) {
                document.getElementById('programCoach').style.display = 'block';
                // Set timeout to hide coaches after 15 seconds
                coachMarkTimeout = setTimeout(() => {
                    document.getElementById('programCoach').style.display = 'none';
                    document.getElementById('teamCoach').style.display = 'none';
                }, 15000);
            }
        });

        // Update the updateCoachMarks function
        function updateCoachMarks() {
            const programCoach = document.getElementById('programCoach');
            const teamCoach = document.getElementById('teamCoach');
            const resourceCoach = document.getElementById('resourceCoach');

            // Clear existing timeout if any
            if (coachMarkTimeout) {
                clearTimeout(coachMarkTimeout);
            }

            if (allData.length === 0) {
                programCoach.style.display = 'block';
                teamCoach.style.display = 'none';
                resourceCoach.style.display = 'none';
                // Set new timeout
                coachMarkTimeout = setTimeout(() => {
                    programCoach.style.display = 'none';
                    teamCoach.style.display = 'none';
                    resourceCoach.style.display = 'none';
                }, 15000);
            } else if (allData.length > 0 && teamMappings.length === 0) {
                programCoach.style.display = 'none';
                teamCoach.style.display = 'block';
                resourceCoach.style.display = 'none';
                // Set new timeout
                coachMarkTimeout = setTimeout(() => {
                    teamCoach.style.display = 'none';
                    resourceCoach.style.display = 'block';
                }, 15000);
            } else if (allData.length > 0 && teamMappings.length > 0) {
                programCoach.style.display = 'none';
                teamCoach.style.display = 'none';
                resourceCoach.style.display = 'block';
                // Set new timeout
                coachMarkTimeout = setTimeout(() => {
                    resourceCoach.style.display = 'none';
                }, 15000);
            } else {
                programCoach.style.display = 'none';
                teamCoach.style.display = 'none';
                resourceCoach.style.display = 'none';
                // Clear timeout as it's no longer needed
                if (coachMarkTimeout) {
                    clearTimeout(coachMarkTimeout);
                    coachMarkTimeout = null;
                }
            }
        }

        // Add event listener for toggle
        document.getElementById('viewToggle').addEventListener('change', updateChart);

        // Add phase progression mapping
        const PHASE_PROGRESS = {
            'Ideation': 10,
            'Intake': 20,
            'Initiation': 30,
            'Implementation': 50,
            'User Acceptance': 80,
            'Production': 100
        };

        function updateGanttChart() {
            if (!allData.length) return;
            
            const ganttContainer = document.getElementById('ganttContainer');
            ganttContainer.innerHTML = '';
            ganttContainer.style.display = 'flex';
            ganttContainer.style.flexDirection = 'column';
            ganttContainer.style.gap = '30px';
            ganttContainer.style.padding = '20px';
            ganttContainer.style.overflowY = 'auto';

            // Get all unique delivery periods and sort them
            const allPeriods = [...new Set(allData.map(item => item['Delivery Period']))].sort();
            const periodToIndex = new Map(allPeriods.map((period, index) => [period, index]));
            const totalPeriods = allPeriods.length;

            // Group projects by program
            const programProjects = new Map();
            allData.forEach(item => {
                if (!programProjects.has(item['Program Name'])) {
                    programProjects.set(item['Program Name'], new Set());
                }
                programProjects.get(item['Program Name']).add(item['Project Name']);
            });

            // Create a chart for each program
            programProjects.forEach((projectSet, program) => {
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.height = '300px';
                chartDiv.style.background = 'white';
                chartDiv.style.borderRadius = '8px';
                chartDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                ganttContainer.appendChild(chartDiv);

                const chart = echarts.init(chartDiv);
                
                // Prepare data for this program's projects
                const projects = Array.from(projectSet).map(project => {
                    const projectData = allData.find(item => item['Project Name'] === project);
                    const progress = PHASE_PROGRESS[projectData['Phase']] || 0;
                    const periodIndex = periodToIndex.get(projectData['Delivery Period']);
                    
                    return {
                        name: project,
                        value: [periodIndex, progress],  // [start position, progress percentage]
                        itemStyle: {
                            color: '#91cc75'
                        },
                        label: {
                            show: true,
                            position: 'right',
                            formatter: `{b} (${progress}%)`
                        },
                        period: projectData['Delivery Period'],
                        phase: projectData['Phase']
                    };
                });

                const option = {
                    title: {
                        text: program,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        formatter: params => {
                            return `${params.name}<br/>
                                Delivery Period: ${params.data.period}<br/>
                                Phase: ${params.data.phase}<br/>
                                Progress: ${params.data.value[1]}%`;
                        }
                    },
                    grid: {
                        left: 200,
                        right: 100,
                        top: 50,
                        bottom: 50,
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: allPeriods,
                        axisLabel: {
                            rotate: 45,
                            interval: 0
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: projects.map(p => p.name),
                        axisLabel: {
                            width: 180,
                            overflow: 'break',
                            interval: 0
                        }
                    },
                    series: [{
                        type: 'custom',
                        renderItem: (params, api) => {
                            const periodIndex = api.value(0);
                            const progress = api.value(1);
                            const start = api.coord([periodIndex, api.value(2)]);
                            const width = api.size([1, 0])[0] * 0.8;  // 80% of period width
                            const height = api.size([0, 1])[1] * 0.6; // 60% of category height
                            
                            // Progress bar background
                            const rectBg = {
                                type: 'rect',
                                shape: {
                                    x: start[0],
                                    y: start[1] - height/2,
                                    width: width,
                                    height: height
                                },
                                style: {
                                    fill: '#f0f0f0'
                                }
                            };
                            
                            // Progress bar
                            const rectProgress = {
                                type: 'rect',
                                shape: {
                                    x: start[0],
                                    y: start[1] - height/2,
                                    width: width * (progress/100),
                                    height: height
                                },
                                style: {
                                    fill: '#91cc75'
                                }
                            };

                            // Progress text
                            const text = {
                                type: 'text',
                                style: {
                                    text: progress + '%',
                                    textAlign: 'center',
                                    fill: '#000',
                                    x: start[0] + width/2,
                                    y: start[1]
                                }
                            };

                            return {
                                type: 'group',
                                children: [rectBg, rectProgress, text]
                            };
                        },
                        dimensions: [
                            {name: 'period', type: 'number'},
                            {name: 'progress', type: 'number'},
                            {name: 'index', type: 'number'}
                        ],
                        encode: {
                            x: 'period',
                            y: 'index'
                        },
                        data: projects.map((p, idx) => ({
                            value: [p.value[0], p.value[1], idx],
                            itemStyle: p.itemStyle,
                            period: p.period,
                            phase: p.phase
                        }))
                    }]
                };

                chart.setOption(option);
                
                // Handle resize
                const resizeObserver = new ResizeObserver(() => {
                    chart.resize();
                });
                resizeObserver.observe(chartDiv);
            });
        }

        // Add window resize handler
        window.addEventListener('resize', () => {
            // ... existing resize handlers ...
            if (resourceState.chart) resourceState.chart.resize();
            if (resourceState.chart && 
                document.getElementById('resourcesTab').style.display === 'block') {
                resourceState.chart.resize();
            }
        });

        // Add ResizeObserver to handle container size changes
        const resizeObserver = new ResizeObserver(entries => {
            if (resourceState.chart) {
                resourceState.chart.resize();
            }
        });
        
        // Observe the container
        const container = document.getElementById('resourceHeatmapChart');
        if (container) {
            resizeObserver.observe(container);
        }

        // New resource heatmap implementation
        function setupResourceHeatmap() {
            const container = document.getElementById('resourceHeatmapChart');
            if (!container) return;

            // Clear existing chart if any
            if (resourceState.chart) {
                resourceState.chart.dispose();
                resourceState.chart = null;
            }

            // Create new chart
            resourceState.chart = echarts.init(container);

            // Set up resize handler
            const resizeObserver = new ResizeObserver(() => {
                if (resourceState.chart) {
                    resourceState.chart.resize();
                }
            });
            resizeObserver.observe(container);

            // Initial render if we have data
            if (resourceState.data.length > 0) {
                renderResourceHeatmap();
            }

            resourceState.initialized = true;
        }

        function renderResourceHeatmap() {
            console.log('Attempting to render heatmap...');
            if (!resourceState.chart || !resourceState.data.length) {
                console.log('Missing chart or data:', {
                    hasChart: !!resourceState.chart,
                    dataLength: resourceState.data.length
                });
                return;
            }

            const container = document.getElementById('resourceHeatmapChart');
            console.log('Container dimensions:', {
                width: container.clientWidth,
                height: container.clientHeight,
                offsetWidth: container.offsetWidth,
                offsetHeight: container.offsetHeight,
                style: container.style.display
            });

            // Process data
            const heatmapData = {};
            resourceState.data.forEach(record => {
                const program = record['Program Name'];
                const jobFunction = record['Job Function'];
                
                if (!program || !jobFunction) return;

                if (!heatmapData[program]) {
                    heatmapData[program] = {};
                }
                if (!heatmapData[program][jobFunction]) {
                    heatmapData[program][jobFunction] = 0;
                }
                heatmapData[program][jobFunction]++;
            });

            const programs = Object.keys(heatmapData);
            const jobFunctions = [...new Set(resourceState.data.map(r => r['Job Function']))];
            const data = [];
            
            console.log('Processed data:', {
                programs: programs.length,
                jobFunctions: jobFunctions.length,
                heatmapData
            });

            programs.forEach((prog, i) => {
                jobFunctions.forEach((func, j) => {
                    data.push([i, j, heatmapData[prog][func] || 0]);
                });
            });

            // Ensure container is visible and sized
            container.style.display = 'block';
            container.style.width = '100%';
            container.style.height = '600px';
            
            // Force reflow
            container.getBoundingClientRect();

            const option = {
                title: {
                    text: 'Program Resource Allocation by Job Function',
                    left: 'center',
                    top: 20
                },
                tooltip: {
                    position: 'top',
                    formatter: function(params) {
                        return `${programs[params.data[0]]}<br/>${jobFunctions[params.data[1]]}<br/>Resources: ${params.data[2]}`;
                    }
                },
                grid: {
                    top: '80px',
                    height: '60%',
                    left: '15%',
                    right: '5%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: programs,
                    splitArea: { show: true },
                    axisLabel: {
                        rotate: 45,
                        interval: 0,
                        fontSize: 10
                    }
                },
                yAxis: {
                    type: 'category',
                    data: jobFunctions,
                    splitArea: { show: true },
                    axisLabel: {
                        fontSize: 10
                    }
                },
                visualMap: {
                    min: 0,
                    max: Math.max(...data.map(d => d[2])),
                    calculable: true,
                    orient: 'horizontal',
                    left: 'center',
                    top: '0',
                    inRange: {
                        color: ['#ffffff', '#7ec2f3', '#499fff', '#1e90ff', '#0050b3']
                    }
                },
                series: [{
                    name: 'Resource Allocation',
                    type: 'heatmap',
                    data: data,
                    label: {
                        show: true,
                        formatter: function(params) {
                            return params.data[2] || '';
                        }
                    },
                    emphasis: {
                        itemStyle: {
                            shadowBlur: 10,
                            shadowColor: 'rgba(0, 0, 0, 0.5)'
                        }
                    }
                }]
            };

            try {
                resourceState.chart.setOption(option);
                console.log('Chart option set successfully');
                // Force a resize after setting options
                setTimeout(() => {
                    if (resourceState.chart) {
                        resourceState.chart.resize();
                        console.log('Chart resized');
                    }
                }, 100);
            } catch (error) {
                console.error('Error setting chart options:', error);
            }
        }

        // Update setupResourceHeatmap to ensure proper initialization
        function setupResourceHeatmap() {
            const container = document.getElementById('resourceHeatmapChart');
            console.log('Setting up heatmap...');
            if (!container) {
                console.error('Container not found');
                return;
            }

            // Ensure container is visible and sized
            container.style.display = 'block';
            container.style.width = '100%';
            container.style.height = '600px';

            // Clear existing chart if any
            if (resourceState.chart) {
                resourceState.chart.dispose();
                resourceState.chart = null;
            }

            // Create new chart
            resourceState.chart = echarts.init(container);
            console.log('Chart initialized');

            // Initial render if we have data
            if (resourceState.data.length > 0) {
                renderResourceHeatmap();
            }

            resourceState.initialized = true;
        }

        // Add event listener for resource tab
        document.querySelector('[data-tab="resourcesTab"]').addEventListener('click', () => {
            if (!resourceState.data.length) return;

            const container = document.getElementById('resourceHeatmapChart');
            container.style.width = '100%';
            container.style.height = '600px';
            // Force reflow
            container.getBoundingClientRect();
            
            if (resourceState.chart) {
                resourceState.chart.dispose();
            }
            
            setupResourceHeatmap();
            
            // Initial render if we have data
            if (resourceState.data.length > 0) {
                renderResourceHeatmap();
            }
        });

        function updateResourceMetrics() {
            // Update total resources count
            const totalResources = resourceState.data.length;
            document.getElementById('totalResources').textContent = totalResources.toLocaleString();

            // Calculate average resources per project
            const uniqueProjects = new Set(resourceState.data.map(r => r['Project Name'])).size;
            const avgResources = uniqueProjects > 0 ? (totalResources / uniqueProjects).toFixed(1) : 0;
            document.getElementById('avgResourcesPerProject').textContent = avgResources;

            // Calculate total estimated man/days
            const totalManDays = resourceState.data.reduce((total, record) => {
                const manDaysStr = record['Estimated Man/Days'];
                if (manDaysStr) {
                    const days = parseFloat(manDaysStr);
                    return total + (isNaN(days) ? 0 : days);
                }
                return total;
            }, 0);

            console.log('Total Estimated Man/Days calculation:', {
                sampleRecords: resourceState.data.slice(0, 5).map(r => ({
                    project: r['Project Name'],
                    manDays: r['Estimated Man/Days']
                })),
                total: totalManDays
            });

            document.getElementById('totalManDays').textContent = 
                Math.round(totalManDays).toLocaleString();
        }
    </script>
</body>
</html>